package com.loopers.mock;

import com.loopers.application.product.dto.ProductSortType;
import com.loopers.domain.product.Product;
import com.loopers.domain.product.ProductRepository;
import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class FakeProductRepository implements ProductRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<Product> data = Collections.synchronizedList(new ArrayList<>());

    @Override
    public Product save(Product product) {
        if (product.getId() == null || product.getId() == 0) {
            // ID가 없는 새 엔티티일 경우 리플렉션으로 ID 주입
            setIdByReflection(product, autoGeneratedId.incrementAndGet());
            data.add(product);
        } else {
            // ID가 있으면 기존 데이터 삭제 후 추가 (업데이트 흉내)
            data.removeIf(p -> p.getId().equals(product.getId()));
            data.add(product);
        }
        return product;
    }

    @Override
    public long getTotalCount() {
        return data.size(); // 전체 데이터 수 반환
    }

    private void setIdByReflection(Product product, Long id) {
        try {
            Field idField = product.getClass().getSuperclass().getDeclaredField("id");
            idField.setAccessible(true);
            ReflectionUtils.setField(idField, product, id);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException("Failed to set ID via reflection", e);
        }
    }

    @Override
    public Optional<Product> findById(Long productId) {
        return data.stream()
                .filter(p -> p.getId() != null && p.getId().equals(productId))
                .findFirst();
    }

    @Override
    public List<Product> findProducts(int page, int size, ProductSortType productSortType) {
        // 1. 정렬
        Comparator<Product> comparator = switch (productSortType) {
            case LATEST -> Comparator.comparing(Product::getCreatedAt, Comparator.nullsLast(Comparator.reverseOrder()));
            case PRICE_ASC -> Comparator.comparing(product -> product.getPrice().getValue());
            case LIKES_DESC -> Comparator.comparing(Product::getLikeCount, Comparator.reverseOrder());
        };

        List<Product> sortedList = data.stream()
                .sorted(comparator)
                .collect(Collectors.toList());

        // 2. 페이징
        int start = (page - 1) * size;
        int end = Math.min(start + size, sortedList.size());

        if (start >= sortedList.size()) {
            return Collections.emptyList(); // 페이지 범위를 벗어나면 빈 리스트 반환
        }

        return sortedList.subList(start, end);
    }

    public void clear() {
        data.clear();
    }
}